1.单例模式：
保证一个类仅有一个实例，并提供一个访问它的全局访问点
适用场景：（线程池，全局缓存）
代理类的方式：
 先创建需要的普通的业务逻辑类，
 再使用代理类
 var ProxySingleton = (function(){
 	var instance;
 	return function(html){
 		if(!instance){
 			instance = new CreateDiv(html);
 		}
 		return instance;
 	}
 })();

2.策略模式
定义一系列算法，把它们一个个封装起来，目的是将算法的使用
与算法的实现分离开来
一个策略模式的程序要有两部分组成
第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。
第二个部分是环境类Context，context接受客户的请求，随后把请求委托给某个策略类。

//策略对象
var strategies = {
	"S": function (salary){
		return salary * 4;
	},
	"A": function (salary){
		return salary * 3;
	},
	"B": function (salary){
		return salary * 2;
	}
}
var calcBonus = function (level, salary){
	return strategies[level](salary);
}
calcBonus('S',20000);



3.代理模式
可以把一些消耗大的操作放在代理里执行，这叫虚拟代理
var miniConsole = (function(){
	var cache = [];
	var handler = function(ev){
		if(ev.keyCode === 113){
			//do sth
		}
	}
	return{
		log: function(){
			var arg = arguments;
			cache.push(function(){
				return miniConsole.log.apply(miniConsole,arg)
			})
		}
	}
})()
缓存代理：
var mult = function(){
	console.log("start calc");
	var a = 1;
	for(var i = 0,l = arguments.length;i < l;i++){
		a = a * argumens[i];
	}
	return a;
}

var proxyMult = (function(){
	var cache = {};
	return function (){
		var args = Array.prototype.join.call(arguments,',');
		if(args in cache){
			return ceche[args];
		}
		return cache[args] = mult.apply(this,argumens);
	}
})
可以在ajax异步请求数据的时候使用缓存代理，比如项目中用到分页的需求，
把拉取过的数据放在缓存中可以减少对后台的请求。

还可以利用高阶函数来动态创建代理

var creatProxyFactory = function(fn){
	var cache = {};
	return function(){
		var args = Array.prototype.join.call(arguments,',');
		if(args in cache){
			return cache[args];
		}
		return cache[args] = fn.apply(this,arguments);
	}
}
var proxyMult = createProxyFactory(mult);
var proxyPlus = createProxyFactory(plus);

代理的种类：
1.防火墙代理
2.远程代理
3.保护代理
4.智能引用代理
5.写时复制代理


4.迭代器模式