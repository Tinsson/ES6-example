模板字符串用`add ${key}`来表达里面需要执行的内容
箭头函数的this的作用域在函数外面
Object.assign()方法的拷贝是浅拷贝（source值的变化会使得输出变化）
尾调用使用时要用严格模式
可以用循环的方法代替递归

object.getOwnPropertyDescriptor能返回某个对象属性的描述对象
getOwnPropertyDescriptors方法能返回该对象所有自身属性的描述对象
可枚举的值要是false就不能被循环出来

symbol 数据不能用new初始化，直接定义就可以
symbol数据不能和其他数据进行计算
在对象内部用symbol定义属性时，symbol必须放在方括号之中[mySymbol]
尽量消除魔术字符串，写成变量好维护
symbol属性名不会被循环遍历 for...in for...of
可以定义非私有的，但又只用于内部的方法
Symbol.for()接受一个字符串参数来寻找是否存在这个字符串的这个symbol
for会被登记在全局中供搜索，而Symbol不会，用Symbol.keyFor()能找到那个key值

proxy会对到达目标对象之前设一道拦截
var proxy = new Proxy(target, handler);
要使得Proxy起作用，必须是针对Proxy实例进行操作，而不是针对目标对象进行操作
proxy对象可以是别的对象的原型
has(target,propKey)拦截propKey in proxy的操作
apply接受三个参数，分别是目标对象，目标对象的上下文（this）和目标对象的参数数组
reflect将Object对象的一些明显属于语言内部的方法放在Reflect对象上

操作二进制文件可用的API  h5新特性
File API
Fetch API
WebSocket
Canvas
AJAX

Set()唯一数组类型，类似数组但不是数组，可以用数组的方法
加入成员为set.add(a)
获取长度为set.size
Set结构的实例有以下属性
Set.prototype.constructor: 构造函数，默认就是Set函数
Set.prototype.size: 返回实例的成员总数
delete(value) 删除某个值
has(value)判断是否包含
clear()清楚所有成员

