模板字符串用`add ${key}`来表达里面需要执行的内容
箭头函数的this的作用域在函数外面
Object.assign()方法的拷贝是浅拷贝（source值的变化会使得输出变化）
尾调用使用时要用严格模式
可以用循环的方法代替递归

object.getOwnPropertyDescriptor能返回某个对象属性的描述对象
getOwnPropertyDescriptors方法能返回该对象所有自身属性的描述对象
可枚举的值要是false就不能被循环出来

symbol 数据不能用new初始化，直接定义就可以
symbol数据不能和其他数据进行计算
在对象内部用symbol定义属性时，symbol必须放在方括号之中[mySymbol]
尽量消除魔术字符串，写成变量好维护
symbol属性名不会被循环遍历 for...in for...of
可以定义非私有的，但又只用于内部的方法
Symbol.for()接受一个字符串参数来寻找是否存在这个字符串的这个symbol
for会被登记在全局中供搜索，而Symbol不会，用Symbol.keyFor()能找到那个key值

proxy会对到达目标对象之前设一道拦截
var proxy = new Proxy(target, handler);
要使得Proxy起作用，必须是针对Proxy实例进行操作，而不是针对目标对象进行操作
proxy对象可以是别的对象的原型
has(target,propKey)拦截propKey in proxy的操作
apply接受三个参数，分别是目标对象，目标对象的上下文（this）和目标对象的参数数组
reflect将Object对象的一些明显属于语言内部的方法放在Reflect对象上

操作二进制文件可用的API  h5新特性
File API
Fetch API
WebSocket
Canvas
AJAX

在===里NaN不等于本身
两个对象也是不相等的
Set()‘唯一’数组类型，类似数组但不是数组，可以用数组的方法
加入成员为set.add(a)
获取长度为set.size
Set结构的实例有以下属性
Set.prototype.constructor: 构造函数，默认就是Set函数
Set.prototype.size: 返回实例的成员总数
delete(value) 删除某个值
has(value)判断是否包含
clear()清楚所有成员
提供四个方法来进行遍历：
keys(): 返回键名
values(): 返回键值
entries(): 返回键值对
forEach(): 使用回调函数遍历每个成员
set结构是没有键值的 所以返回的 keys和values是一样的
用set结构能实现并集，交集，差集

WeakSet‘成员’只能是对象
var a = [2,2];
var ws = new WeakSet(a);//报错
WeakSet结构有三个方法
add(value)添加新成员
delete(value)清除制定成员
has(value)是否包含
主要作用是不会引起内存泄漏（弱引用，随时消失）


Map结构类型“值-值”的对应关系
对同样一个键多次赋值，后面的值会覆盖前面的值
var map = new Map();
map.set(['a'],500);
map.get(['a']); //undefined
Map的键实际上是和内存地址绑定的
如果键是一个简单类型的值（数字，字符串，布尔值），只要两个值严格相等，
就会视为一个键，包括0和-0  NaN
size 成员总数
set设置键值
get(key) , has(key) , delete(key) , clear()
Map结构的默认遍历器借口是entries
[...map.keys()]转换数组类型
Map没有map和filter方法但有forEach() 第二个绑定this
map.forEach(function(value,key,map){
	this.report();
},reporter);
这里的this会指向reporter

WeakMap只要是值接受对象作为键名，不接受其他类型的值作为键名，
键名所指向的对象不计入垃圾回收机制
专用场合是键所对应的对象随时在未来可能会消失，有助于防止内存泄漏
var wm = new WeakMap();
var element = document.querySelector(".element");
wm.set(element,"Original");
wm.get(element)//Original
element.parentNode.removeChild(element);
element = null;
wm.get(element) //undefined
没有size,所以不存在遍历操作(keys(),values(),entries())
只能用 get(),set(),has(),delete()

Iterator的作用有三：
一、为各种数据结构提供一个统一的简便的访问借口
二、使得数据结构的成员能够按某种次序排列
三、供for...of消费
要在Symbol.iterator的属性上部署遍历器生成方法
[Symbol.iterator](){return this;}
类似数组的对象，部署Iterator接口是直接引用数组的Iterator接口
NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.Iterator];
实现iterator最简单的方法是用Genertor函数
let obj = {
	* [Symbol.iterator](){
		yield 'hello';
		yield 'world';
	}
}
for(let x of obj){
	console.log(x);
}
return 方法必须返回一个对象

for...of使用的范围包括数组、Set和Map结构、某些类似数组的对象
如（arguments对象、DOM NodeList对象）Generator对象以及字符串
set和map循环的顺序是按各个成员添加进去的顺序
set是一个值，map是一个数组

forEach循环的问题： 中途不能跳出循环，break命令或者return命令都不能奏效
for...in的几个缺点
数组的键名是数字，但是这个循环的键名是字符串"0","1"
还会遍历手动添加的其他键，包括原型链上的键
某些情况下，for...in会以任意顺序遍历键名


调用Generator函数后，函数不执行，返回一个指向内部状态的指针对象
（Iterator Object）
yield语句是暂停执行的标记，而next方法可以恢复执行
遍历器对象的next方法的运行逻辑：
1.遇到yield就暂停执行，返回一个值作为返回的value属性值
2.下一次next方法继续往下执行直到下一个yield语句
3.如果没有新的yield语句一直到return为止
4.如果该函数没有return语句，就会返回undefined

yeild语句不能放在普通函数中
如果yeild语句用在一个表达式中必须放在圆括号里面
yield本身没有返回值，或者说返回undefined，但是next方法可以带一个参数，这个参数就是会当成上一个yield语句的返回值
next方法第一次使用时不能带有参数
有遍历器借口的方法都能将Generator函数返回的Iterator对象作为参数
function* numbers(){
	yield 1
	yield 2
	return 3
	yield 4
}
[...numbers()]//[1,2]
Array.from(numbers())// [1,2]
let[x,y] = numbers();
x // 1
y // 2
可以在Generator函数外部执行语句中throw一个错误在函数内部捕捉这个错误
throw的参数会被catch语句接收
throw方法被捕获以后会附带执行下一条yield语句
Generator函数还有一个return方法可以返回给定的值并终结遍历Generator函数
try...finally用于执行一段代码结束后执行块里的语句
如果在Generator函数里调用Generator函数是不会有效果的
需要用yield*语句在Generator函数里执行另一个Generator函数
比如：
function* bar(){
	yield 1;
	yield* foo();
	yield 2;
}
function* foo(){
	yield 3;
}
var g = bar();
任何数据结构只要有Iterator接口，就可以被yield*遍历
yield*可以很方便地取出嵌套数组的所有成员
function* iterTree(tree){
	if(Array.isArray(tree)){
		for(let i=0;i< tree.length;i++){
			yield* iterTree(tree[i]);
		}
	}else{
		yield tree;
	}
}
const tree = [1,[2,3],[4,5]];
for(let x of iterTree(tree)){
	console.log(x);
}
//1
//2
//...
对象属性是Generator函数可以简写成
let obj = {
	* gfunc(){
		...
	}
}
Generator函数不是构造函数不能跟new命令一起用
应用有：1.异步操作的同步化表达
2.控制流管理
3.部署Iterator接口
4.作为数据结构